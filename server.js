// Generated by CoffeeScript 1.6.3
(function() {
  var child_process, fs, http, logFileName, logStream, logToFile, onReady, port, quit, routes, server, use,
    __slice = [].slice;

  if (typeof isNodeJs === "undefined" || typeof runTest === "undefined") {
    (function() {
      var root;
      root = typeof window === "undefined" ? global : window;
      if (typeof isNodeJs === "undefined") {
        root.isNodeJs = typeof process !== "undefined";
      }
      if (typeof isPhoneGap === "undefined") {
        root.isPhoneGap = typeof document.ondeviceready !== "undefined";
      }
      if (typeof runTest === "undefined") {
        return root.runTest = true;
      }
    })();
  }

  use = isNodeJs ? (function(module) {
    return require(module);
  }) : (function(module) {
    return window[module];
  });

  onReady = function(fn) {
    if (isNodeJs) {
      return process.nextTick(fn);
    } else {
      if (document.readystate !== "complete") {
        return fn();
      } else {
        return setTimeout((function() {
          return onReady(fn);
        }), 17);
      }
    }
  };

  fs = require("fs");

  child_process = require("child_process");

  logStream = void 0;

  logFileName = void 0;

  logToFile = function(arr, cb) {
    var name, now, oldfile;
    now = (new Date()).toISOString();
    name = "../logs/log-" + (now.slice(0, 10)) + ".log";
    if (name !== logFileName) {
      if (logStream) {
        oldfile = logFileName;
        logStream.on("close", function() {
          return child_process.exec("xz " + oldfile);
        });
        logStream.end();
      }
      logStream = fs.createWriteStream(name, {
        flags: "a"
      });
      logFileName = name;
    }
    return logStream.write("" + (JSON.stringify([now].concat(arr))) + "\n", "utf8", cb);
  };

  routes = {
    api: {
      err: function() {
        throw "error";
      },
      log: function(req, res) {
        var data;
        data = "";
        req.setEncoding("utf8");
        req.on("data", function(chunk) {
          return data += chunk;
        });
        return req.on("end", function() {
          logToFile([req.url, req.headers, data]);
          res.writeHead(200, {
            connection: "keep-alive"
          });
          return res.end("ok");
        });
      }
    }
  };

  port = process.env.API_PORT || 4444;

  http = require("http");

  server = http.createServer(function(req, res) {
    var part, route, _i, _len, _ref;
    logToFile([req.url, req.headers]);
    console.log(req, res);
    route = routes;
    _ref = req.url.split("/").filter(function(a) {
      return a;
    });
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      part = _ref[_i];
      route = route[part];
      if (typeof route === "function") {
        return route(req, res);
      }
      if (typeof route === "undefined") {
        res.writeHead(404, {});
        res.end("404 not found");
        return;
      }
    }
  });

  server.listen(port, "localhost");

  onReady(function() {
    logToFile(["server started"]);
    return console.log("serving on port " + port);
  });

  quit = function() {
    return process.exit(1);
  };

  process.on("uncaughtException", window.onerror = function() {
    var args;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return logToFile(["error occured", String(args)], quit);
  });

}).call(this);
